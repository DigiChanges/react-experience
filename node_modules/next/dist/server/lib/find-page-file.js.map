{"version":3,"sources":["../../../server/lib/find-page-file.ts"],"names":["readdir","fs","isTrueCasePagePath","pagePath","pagesDir","pageSegments","split","pathSeparator","filter","Boolean","segmentExistsPromises","map","segment","i","segmentParentDir","slice","parentDirEntries","includes","Promise","all","every","findPageFile","rootDir","normalizedPagePath","pageExtensions","foundPagePaths","extension","relativePagePath","startsWith","endsWith","push","relativePagePathWithIndex","pagePathWithIndex","length","chalk","cyan"],"mappings":"uEAAA,0BACA,uEACA,qDACA,2CACA,8CACA,0B,mFAEA,KAAMA,CAAAA,OAAO,CAAG,oBAAUC,YAAGD,OAAb,CAAhB,CAEA,cAAeE,CAAAA,kBAAf,CAAkCC,QAAlC,CAAoDC,QAApD,CAAsE,CACpE,KAAMC,CAAAA,YAAY,CAAG,oBAAUF,QAAV,EAAoBG,KAApB,CAA0BC,SAA1B,EAAyCC,MAAzC,CAAgDC,OAAhD,CAArB,CAEA,KAAMC,CAAAA,qBAAqB,CAAGL,YAAY,CAACM,GAAb,CAAiB,MAAOC,OAAP,CAAgBC,CAAhB,GAAsB,CACnE,KAAMC,CAAAA,gBAAgB,CAAG,eAAKV,QAAL,CAAe,GAAGC,YAAY,CAACU,KAAb,CAAmB,CAAnB,CAAsBF,CAAtB,CAAlB,CAAzB,CACA,KAAMG,CAAAA,gBAAgB,CAAG,KAAMhB,CAAAA,OAAO,CAACc,gBAAD,CAAtC,CACA,MAAOE,CAAAA,gBAAgB,CAACC,QAAjB,CAA0BL,OAA1B,CAAP,CACD,CAJ6B,CAA9B,CAMA,MAAO,CAAC,KAAMM,CAAAA,OAAO,CAACC,GAAR,CAAYT,qBAAZ,CAAP,EAA2CU,KAA3C,CAAiDX,OAAjD,CAAP,CACD,CAEM,cAAeY,CAAAA,YAAf,CACLC,OADK,CAELC,kBAFK,CAGLC,cAHK,CAImB,CACxB,GAAIC,CAAAA,cAAwB,CAAG,EAA/B,CAEA,IAAK,KAAMC,CAAAA,SAAX,GAAwBF,CAAAA,cAAxB,CAAwC,CACtC,KAAMG,CAAAA,gBAAgB,CAAI,GAAEJ,kBAAmB,IAAGG,SAAU,EAA5D,CACA,KAAMvB,CAAAA,QAAQ,CAAG,eAAKmB,OAAL,CAAcK,gBAAd,CAAjB,CAEA;AACA;AACA,GACEJ,kBAAkB,CAACK,UAAnB,CAA8B,QAA9B,GACA,CAACL,kBAAkB,CAACM,QAAnB,CAA4B,QAA5B,CAFH,CAGE,CACA,GAAI,KAAM,6BAAY1B,QAAZ,CAAV,CAAiC,CAC/BsB,cAAc,CAACK,IAAf,CAAoBH,gBAApB,EACD,CACF,CAED,KAAMI,CAAAA,yBAAyB,CAAG,eAChCR,kBADgC,CAE/B,SAAQG,SAAU,EAFa,CAAlC,CAIA,KAAMM,CAAAA,iBAAiB,CAAG,eAAKV,OAAL,CAAcS,yBAAd,CAA1B,CACA,GAAI,KAAM,6BAAYC,iBAAZ,CAAV,CAA0C,CACxCP,cAAc,CAACK,IAAf,CAAoBC,yBAApB,EACD,CACF,CAED,GAAIN,cAAc,CAACQ,MAAf,CAAwB,CAA5B,CAA+B,CAC7B,MAAO,KAAP,CACD,CAED,GAAI,EAAE,KAAM/B,CAAAA,kBAAkB,CAACuB,cAAc,CAAC,CAAD,CAAf,CAAoBH,OAApB,CAA1B,CAAJ,CAA6D,CAC3D,MAAO,KAAP,CACD,CAED,GAAIG,cAAc,CAACQ,MAAf,CAAwB,CAA5B,CAA+B,CAC7B,cACG,4BAA2BC,eAAMC,IAAN,CAC1B,eAAK,OAAL,CAAcV,cAAc,CAAC,CAAD,CAA5B,CAD0B,CAE1B,QAAOS,eAAMC,IAAN,CACP,eAAK,OAAL,CAAcV,cAAc,CAAC,CAAD,CAA5B,CADO,CAEP,oBAAmBS,eAAMC,IAAN,CAAWZ,kBAAX,CAA+B,GALtD,EAOD,CAED,MAAOE,CAAAA,cAAc,CAAC,CAAD,CAArB,CACD","sourcesContent":["import { join, sep as pathSeparator, normalize } from 'path'\nimport chalk from 'next/dist/compiled/chalk'\nimport { isWriteable } from '../../build/is-writeable'\nimport { warn } from '../../build/output/log'\nimport fs from 'fs'\nimport { promisify } from 'util'\n\nconst readdir = promisify(fs.readdir)\n\nasync function isTrueCasePagePath(pagePath: string, pagesDir: string) {\n  const pageSegments = normalize(pagePath).split(pathSeparator).filter(Boolean)\n\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = join(pagesDir, ...pageSegments.slice(0, i))\n    const parentDirEntries = await readdir(segmentParentDir)\n    return parentDirEntries.includes(segment)\n  })\n\n  return (await Promise.all(segmentExistsPromises)).every(Boolean)\n}\n\nexport async function findPageFile(\n  rootDir: string,\n  normalizedPagePath: string,\n  pageExtensions: string[]\n): Promise<string | null> {\n  let foundPagePaths: string[] = []\n\n  for (const extension of pageExtensions) {\n    const relativePagePath = `${normalizedPagePath}.${extension}`\n    const pagePath = join(rootDir, relativePagePath)\n\n    // only /index and /sub/index when /sub/index/index.js is allowed\n    // see test/integration/route-indexes for expected index handling\n    if (\n      normalizedPagePath.startsWith('/index') ||\n      !normalizedPagePath.endsWith('/index')\n    ) {\n      if (await isWriteable(pagePath)) {\n        foundPagePaths.push(relativePagePath)\n      }\n    }\n\n    const relativePagePathWithIndex = join(\n      normalizedPagePath,\n      `index.${extension}`\n    )\n    const pagePathWithIndex = join(rootDir, relativePagePathWithIndex)\n    if (await isWriteable(pagePathWithIndex)) {\n      foundPagePaths.push(relativePagePathWithIndex)\n    }\n  }\n\n  if (foundPagePaths.length < 1) {\n    return null\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null\n  }\n\n  if (foundPagePaths.length > 1) {\n    warn(\n      `Duplicate page detected. ${chalk.cyan(\n        join('pages', foundPagePaths[0])\n      )} and ${chalk.cyan(\n        join('pages', foundPagePaths[1])\n      )} both resolve to ${chalk.cyan(normalizedPagePath)}.`\n    )\n  }\n\n  return foundPagePaths[0]\n}\n"]}