{"version":3,"sources":["../../../../build/webpack/plugins/pages-manifest-plugin.ts"],"names":["PagesManifestPlugin","constructor","serverless","apply","compiler","hooks","emit","tap","compilation","chunks","pages","chunk","result","SERVERLESS_ROUTE_NAME_REGEX","ROUTE_NAME_REGEX","exec","name","pagePath","replace","assets","PAGES_MANIFEST","RawSource","JSON","stringify"],"mappings":"4DACA,+CACA,6DAQA;AACA;AACA;AACe,KAAMA,CAAAA,mBAAsC,CAGzDC,WAAW,CAACC,UAAD,CAAsB,MAFjCA,UAEiC,QAC/B,KAAKA,UAAL,CAAkBA,UAAlB,CACD,CAEDC,KAAK,CAACC,QAAD,CAA2B,CAC9BA,QAAQ,CAACC,KAAT,CAAeC,IAAf,CAAoBC,GAApB,CAAwB,qBAAxB,CAAgDC,WAAD,EAAiB,CAC9D,KAAM,CAAEC,MAAF,EAAaD,WAAnB,CACA,KAAME,CAAAA,KAAoB,CAAG,EAA7B,CAEA,IAAK,KAAMC,CAAAA,KAAX,GAAoBF,CAAAA,MAApB,CAA4B,CAC1B,KAAMG,CAAAA,MAAM,CAAG,CAAC,KAAKV,UAAL,CACZW,sCADY,CAEZC,2BAFW,EAGbC,IAHa,CAGRJ,KAAK,CAACK,IAHE,CAAf,CAKA,GAAI,CAACJ,MAAL,CAAa,CACX,SACD,CAED,KAAMK,CAAAA,QAAQ,CAAGL,MAAM,CAAC,CAAD,CAAvB,CAEA,GAAI,CAACK,QAAL,CAAe,CACb,SACD,CAED;AACAP,KAAK,CAAE,IAAGO,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,GAAxB,CAA6B,EAAlC,CAAL,CAA4CP,KAAK,CAACK,IAAN,CAAWE,OAAX,CAC1C,KAD0C,CAE1C,GAF0C,CAA5C,CAID,CAED,GAAI,MAAOR,CAAAA,KAAK,CAAC,QAAD,CAAZ,GAA2B,WAA/B,CAA4C,CAC1CA,KAAK,CAAC,GAAD,CAAL,CAAaA,KAAK,CAAC,QAAD,CAAlB,CACD,CAEDF,WAAW,CAACW,MAAZ,CAAmBC,yBAAnB,EAAqC,GAAIC,0BAAJ,CAAcC,IAAI,CAACC,SAAL,CAAeb,KAAf,CAAd,CAArC,CACD,CAhCD,EAiCD,CAzCwD,C","sourcesContent":["import { Compiler, Plugin } from 'webpack'\nimport { RawSource } from 'webpack-sources'\nimport {\n  PAGES_MANIFEST,\n  ROUTE_NAME_REGEX,\n  SERVERLESS_ROUTE_NAME_REGEX,\n} from '../../../next-server/lib/constants'\n\nexport type PagesManifest = { [page: string]: string }\n\n// This plugin creates a pages-manifest.json from page entrypoints.\n// This is used for mapping paths like `/` to `.next/server/static/<buildid>/pages/index.js` when doing SSR\n// It's also used by next export to provide defaultPathMap\nexport default class PagesManifestPlugin implements Plugin {\n  serverless: boolean\n\n  constructor(serverless: boolean) {\n    this.serverless = serverless\n  }\n\n  apply(compiler: Compiler): void {\n    compiler.hooks.emit.tap('NextJsPagesManifest', (compilation) => {\n      const { chunks } = compilation\n      const pages: PagesManifest = {}\n\n      for (const chunk of chunks) {\n        const result = (this.serverless\n          ? SERVERLESS_ROUTE_NAME_REGEX\n          : ROUTE_NAME_REGEX\n        ).exec(chunk.name)\n\n        if (!result) {\n          continue\n        }\n\n        const pagePath = result[1]\n\n        if (!pagePath) {\n          continue\n        }\n\n        // Write filename, replace any backslashes in path (on windows) with forwardslashes for cross-platform consistency.\n        pages[`/${pagePath.replace(/\\\\/g, '/')}`] = chunk.name.replace(\n          /\\\\/g,\n          '/'\n        )\n      }\n\n      if (typeof pages['/index'] !== 'undefined') {\n        pages['/'] = pages['/index']\n      }\n\n      compilation.assets[PAGES_MANIFEST] = new RawSource(JSON.stringify(pages))\n    })\n  }\n}\n"]}