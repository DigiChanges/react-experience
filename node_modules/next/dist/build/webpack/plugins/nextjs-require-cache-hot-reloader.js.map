{"version":3,"sources":["../../../../build/webpack/plugins/nextjs-require-cache-hot-reloader.ts"],"names":["deleteCache","path","require","cache","e","code","NextJsRequireCacheHotReloader","prevAssets","apply","compiler","hooks","afterEmit","tapAsync","compilation","callback","assets","f","Object","keys","existsAt"],"mappings":"kFACA,sBAEA,QAASA,CAAAA,WAAT,CAAqBC,IAArB,CAAmC,CACjC,GAAI,CACF,MAAOC,CAAAA,OAAO,CAACC,KAAR,CAAc,qBAAaF,IAAb,CAAd,CAAP,CACD,CAAC,MAAOG,CAAP,CAAU,CACV,GAAIA,CAAC,CAACC,IAAF,GAAW,QAAf,CAAyB,KAAMD,CAAAA,CAAN,CAC1B,CAJD,OAIU,CACR,MAAOF,CAAAA,OAAO,CAACC,KAAR,CAAcF,IAAd,CAAP,CACD,CACF,CAED;AACO,KAAMK,CAAAA,6BAAgD,oBAC3DC,UAD2D,CACzC,IADyC,EAG3DC,KAAK,CAACC,QAAD,CAAqB,CACxBA,QAAQ,CAACC,KAAT,CAAeC,SAAf,CAAyBC,QAAzB,CACE,+BADF,CAEE,CAACC,WAAD,CAAcC,QAAd,GAA2B,CACzB,KAAM,CAAEC,MAAF,EAAaF,WAAnB,CAEA,GAAI,KAAKN,UAAT,CAAqB,CACnB,IAAK,KAAMS,CAAAA,CAAX,GAAgBC,CAAAA,MAAM,CAACC,IAAP,CAAYH,MAAZ,CAAhB,CAAqC,CACnCf,WAAW,CAACe,MAAM,CAACC,CAAD,CAAN,CAAUG,QAAX,CAAX,CACD,CACD,IAAK,KAAMH,CAAAA,CAAX,GAAgBC,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAKX,UAAjB,CAAhB,CAA8C,CAC5C,GAAI,CAACQ,MAAM,CAACC,CAAD,CAAX,CAAgB,CACdhB,WAAW,CAAC,KAAKO,UAAL,CAAgBS,CAAhB,EAAmBG,QAApB,CAAX,CACD,CACF,CACF,CACD,KAAKZ,UAAL,CAAkBQ,MAAlB,CAEAD,QAAQ,GACT,CAlBH,EAoBD,CAxB0D,C","sourcesContent":["import { Compiler, Plugin } from 'webpack'\nimport { realpathSync } from 'fs'\n\nfunction deleteCache(path: string) {\n  try {\n    delete require.cache[realpathSync(path)]\n  } catch (e) {\n    if (e.code !== 'ENOENT') throw e\n  } finally {\n    delete require.cache[path]\n  }\n}\n\n// This plugin flushes require.cache after emitting the files. Providing 'hot reloading' of server files.\nexport class NextJsRequireCacheHotReloader implements Plugin {\n  prevAssets: any = null\n\n  apply(compiler: Compiler) {\n    compiler.hooks.afterEmit.tapAsync(\n      'NextJsRequireCacheHotReloader',\n      (compilation, callback) => {\n        const { assets } = compilation\n\n        if (this.prevAssets) {\n          for (const f of Object.keys(assets)) {\n            deleteCache(assets[f].existsAt)\n          }\n          for (const f of Object.keys(this.prevAssets)) {\n            if (!assets[f]) {\n              deleteCache(this.prevAssets[f].existsAt)\n            }\n          }\n        }\n        this.prevAssets = assets\n\n        callback()\n      }\n    )\n  }\n}\n"]}