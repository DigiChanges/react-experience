{"version":3,"sources":["../../../../build/webpack/loaders/next-serverless-loader.ts"],"names":["nextServerlessLoader","distDir","absolutePagePath","page","buildId","canonicalBase","assetPrefix","absoluteAppPath","absoluteDocumentPath","absoluteErrorPath","generateEtags","basePath","runtimeConfig","previewProps","loadedEnvFiles","query","substr","buildManifest","BUILD_MANIFEST","replace","reactLoadableManifest","REACT_LOADABLE_MANIFEST","routesManifest","ROUTES_MANIFEST","escapedBuildId","pageIsDynamicRoute","encodedPreviewProps","JSON","parse","envLoading","runtimeConfigImports","runtimeConfigSetter","dynamicRouteImports","dynamicRouteMatcher","rewriteImports","handleRewrites","match","API_ROUTE"],"mappings":"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","sourcesContent":["import devalue from 'next/dist/compiled/devalue'\nimport escapeRegexp from 'next/dist/compiled/escape-string-regexp'\nimport { join } from 'path'\nimport { parse } from 'querystring'\nimport { loader } from 'webpack'\nimport { API_ROUTE } from '../../../lib/constants'\nimport {\n  BUILD_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  ROUTES_MANIFEST,\n} from '../../../next-server/lib/constants'\nimport { isDynamicRoute } from '../../../next-server/lib/router/utils'\nimport { __ApiPreviewProps } from '../../../next-server/server/api-utils'\n\nexport type ServerlessLoaderQuery = {\n  page: string\n  distDir: string\n  absolutePagePath: string\n  absoluteAppPath: string\n  absoluteDocumentPath: string\n  absoluteErrorPath: string\n  buildId: string\n  assetPrefix: string\n  generateEtags: string\n  canonicalBase: string\n  basePath: string\n  runtimeConfig: string\n  previewProps: string\n  loadedEnvFiles: string\n}\n\nconst nextServerlessLoader: loader.Loader = function () {\n  const {\n    distDir,\n    absolutePagePath,\n    page,\n    buildId,\n    canonicalBase,\n    assetPrefix,\n    absoluteAppPath,\n    absoluteDocumentPath,\n    absoluteErrorPath,\n    generateEtags,\n    basePath,\n    runtimeConfig,\n    previewProps,\n    loadedEnvFiles,\n  }: ServerlessLoaderQuery =\n    typeof this.query === 'string' ? parse(this.query.substr(1)) : this.query\n\n  const buildManifest = join(distDir, BUILD_MANIFEST).replace(/\\\\/g, '/')\n  const reactLoadableManifest = join(distDir, REACT_LOADABLE_MANIFEST).replace(\n    /\\\\/g,\n    '/'\n  )\n  const routesManifest = join(distDir, ROUTES_MANIFEST).replace(/\\\\/g, '/')\n\n  const escapedBuildId = escapeRegexp(buildId)\n  const pageIsDynamicRoute = isDynamicRoute(page)\n\n  const encodedPreviewProps = devalue(\n    JSON.parse(previewProps) as __ApiPreviewProps\n  )\n\n  const envLoading = `\n    const { processEnv } = require('next/dist/lib/load-env-config')\n    processEnv(${loadedEnvFiles})\n  `\n\n  const runtimeConfigImports = runtimeConfig\n    ? `\n      const { setConfig } = require('next/config')\n    `\n    : ''\n\n  const runtimeConfigSetter = runtimeConfig\n    ? `\n      const runtimeConfig = ${runtimeConfig}\n      setConfig(runtimeConfig)\n    `\n    : 'const runtimeConfig = {}'\n\n  const dynamicRouteImports = pageIsDynamicRoute\n    ? `\n    const { getRouteMatcher } = require('next/dist/next-server/lib/router/utils/route-matcher');\n      const { getRouteRegex } = require('next/dist/next-server/lib/router/utils/route-regex');\n  `\n    : ''\n\n  const dynamicRouteMatcher = pageIsDynamicRoute\n    ? `\n    const dynamicRouteMatcher = getRouteMatcher(getRouteRegex(\"${page}\"))\n  `\n    : ''\n\n  const rewriteImports = `\n    const { rewrites } = require('${routesManifest}')\n    const { pathToRegexp, default: pathMatch } = require('next/dist/next-server/server/lib/path-match')\n  `\n\n  const handleRewrites = `\n    const getCustomRouteMatcher = pathMatch(true)\n    const {prepareDestination} = require('next/dist/next-server/server/router')\n\n    function handleRewrites(parsedUrl) {\n      for (const rewrite of rewrites) {\n        const matcher = getCustomRouteMatcher(rewrite.source)\n        const params = matcher(parsedUrl.pathname)\n\n        if (params) {\n          const { parsedDestination } = prepareDestination(\n            rewrite.destination,\n            params,\n            parsedUrl.query\n          )\n          Object.assign(parsedUrl.query, parsedDestination.query, params)\n          delete parsedDestination.query\n\n          Object.assign(parsedUrl, parsedDestination)\n\n          if (parsedUrl.pathname === '${page}'){\n            break\n          }\n          ${\n            pageIsDynamicRoute\n              ? `\n            const dynamicParams = dynamicRouteMatcher(parsedUrl.pathname);\\\n            if (dynamicParams) {\n              parsedUrl.query = {\n                ...parsedUrl.query,\n                ...dynamicParams\n              }\n              break\n            }\n          `\n              : ''\n          }\n        }\n      }\n\n      return parsedUrl\n    }\n  `\n\n  if (page.match(API_ROUTE)) {\n    return `\n      import initServer from 'next-plugin-loader?middleware=on-init-server!'\n      import onError from 'next-plugin-loader?middleware=on-error-server!'\n      import 'next/dist/next-server/server/node-polyfill-fetch'\n\n      ${envLoading}\n      ${runtimeConfigImports}\n      ${\n        /*\n          this needs to be called first so its available for any other imports\n        */\n        runtimeConfigSetter\n      }\n      ${dynamicRouteImports}\n      const { parse } = require('url')\n      const { apiResolver } = require('next/dist/next-server/server/api-utils')\n      ${rewriteImports}\n\n      ${dynamicRouteMatcher}\n\n      ${handleRewrites}\n\n      export default async (req, res) => {\n        try {\n          await initServer()\n\n          ${\n            basePath\n              ? `\n          if(req.url.startsWith('${basePath}')) {\n            req.url = req.url.replace('${basePath}', '')\n          }\n          `\n              : ''\n          }\n          const parsedUrl = handleRewrites(parse(req.url, true))\n\n          const params = ${\n            pageIsDynamicRoute\n              ? `dynamicRouteMatcher(parsedUrl.pathname)`\n              : `{}`\n          }\n\n          const resolver = require('${absolutePagePath}')\n          await apiResolver(\n            req,\n            res,\n            Object.assign({}, parsedUrl.query, params ),\n            resolver,\n            ${encodedPreviewProps},\n            onError\n          )\n        } catch (err) {\n          console.error(err)\n          await onError(err)\n\n          if (err.code === 'DECODE_FAILED') {\n            res.statusCode = 400\n            res.end('Bad Request')\n          } else {\n            res.statusCode = 500\n            res.end('Internal Server Error')\n          }\n        }\n      }\n    `\n  } else {\n    return `\n    import initServer from 'next-plugin-loader?middleware=on-init-server!'\n    import onError from 'next-plugin-loader?middleware=on-error-server!'\n    import 'next/dist/next-server/server/node-polyfill-fetch'\n\n    ${envLoading}\n    ${runtimeConfigImports}\n    ${\n      // this needs to be called first so its available for any other imports\n      runtimeConfigSetter\n    }\n    const {parse} = require('url')\n    const {parse: parseQs} = require('querystring')\n    const {renderToHTML} = require('next/dist/next-server/server/render');\n    const { tryGetPreviewData } = require('next/dist/next-server/server/api-utils');\n    const {sendHTML} = require('next/dist/next-server/server/send-html');\n    const {sendPayload} = require('next/dist/next-server/server/send-payload');\n    const buildManifest = require('${buildManifest}');\n    const reactLoadableManifest = require('${reactLoadableManifest}');\n    const Document = require('${absoluteDocumentPath}').default;\n    const Error = require('${absoluteErrorPath}').default;\n    const App = require('${absoluteAppPath}').default;\n    ${dynamicRouteImports}\n    ${rewriteImports}\n\n    const ComponentInfo = require('${absolutePagePath}')\n\n    const Component = ComponentInfo.default\n    export default Component\n    export const unstable_getStaticParams = ComponentInfo['unstable_getStaticParam' + 's']\n    export const getStaticProps = ComponentInfo['getStaticProp' + 's']\n    export const getStaticPaths = ComponentInfo['getStaticPath' + 's']\n    export const getServerSideProps = ComponentInfo['getServerSideProp' + 's']\n\n    // kept for detecting legacy exports\n    export const unstable_getStaticProps = ComponentInfo['unstable_getStaticProp' + 's']\n    export const unstable_getStaticPaths = ComponentInfo['unstable_getStaticPath' + 's']\n    export const unstable_getServerProps = ComponentInfo['unstable_getServerProp' + 's']\n\n    ${dynamicRouteMatcher}\n    ${handleRewrites}\n\n    export const config = ComponentInfo['confi' + 'g'] || {}\n    export const _app = App\n    export async function renderReqToHTML(req, res, renderMode, _renderOpts, _params) {\n      const fromExport = renderMode === 'export' || renderMode === true;\n      ${\n        basePath\n          ? `\n      if(req.url.startsWith('${basePath}')) {\n        req.url = req.url.replace('${basePath}', '')\n      }\n      `\n          : ''\n      }\n      const options = {\n        App,\n        Document,\n        buildManifest,\n        getStaticProps,\n        getServerSideProps,\n        getStaticPaths,\n        reactLoadableManifest,\n        canonicalBase: \"${canonicalBase}\",\n        buildId: \"${buildId}\",\n        assetPrefix: \"${assetPrefix}\",\n        runtimeConfig: runtimeConfig.publicRuntimeConfig || {},\n        previewProps: ${encodedPreviewProps},\n        env: process.env,\n        basePath: \"${basePath}\",\n        ..._renderOpts\n      }\n      let _nextData = false\n      let parsedUrl\n\n      try {\n        parsedUrl = handleRewrites(parse(req.url, true))\n\n        if (parsedUrl.pathname.match(/_next\\\\/data/)) {\n          _nextData = true\n          parsedUrl.pathname = parsedUrl.pathname\n            .replace(new RegExp('/_next/data/${escapedBuildId}/'), '/')\n            .replace(/\\\\.json$/, '')\n        }\n\n        const renderOpts = Object.assign(\n          {\n            Component,\n            pageConfig: config,\n            nextExport: fromExport,\n            isDataReq: _nextData,\n          },\n          options,\n        )\n\n        ${\n          page === '/_error'\n            ? `\n          if (!res.statusCode) {\n            res.statusCode = 404\n          }\n        `\n            : ''\n        }\n\n        ${\n          pageIsDynamicRoute\n            ? `const params = fromExport && !getStaticProps && !getServerSideProps ? {} : dynamicRouteMatcher(parsedUrl.pathname) || {};`\n            : `const params = {};`\n        }\n        ${\n          // Temporary work around: `x-now-route-matches` is a platform header\n          // _only_ set for `Prerender` requests. We should move this logic\n          // into our builder to ensure we're decoupled. However, this entails\n          // removing reliance on `req.url` and using `req.query` instead\n          // (which is needed for \"custom routes\" anyway).\n          pageIsDynamicRoute\n            ? `const nowParams = req.headers && req.headers[\"x-now-route-matches\"]\n              ? getRouteMatcher(\n                  (function() {\n                    const { re, groups } = getRouteRegex(\"${page}\");\n                    return {\n                      re: {\n                        // Simulate a RegExp match from the \\`req.url\\` input\n                        exec: str => {\n                          const obj = parseQs(str);\n                          return Object.keys(obj).reduce(\n                            (prev, key) =>\n                              Object.assign(prev, {\n                                [key]: obj[key]\n                              }),\n                            {}\n                          );\n                        }\n                      },\n                      groups\n                    };\n                  })()\n                )(req.headers[\"x-now-route-matches\"])\n              : null;\n          `\n            : `const nowParams = null;`\n        }\n        // make sure to set renderOpts to the correct params e.g. _params\n        // if provided from worker or params if we're parsing them here\n        renderOpts.params = _params || params\n\n        const isFallback = parsedUrl.query.__nextFallback\n\n        const previewData = tryGetPreviewData(req, res, options.previewProps)\n        const isPreviewMode = previewData !== false\n\n        let result = await renderToHTML(req, res, \"${page}\", Object.assign({}, getStaticProps ? { ...(parsedUrl.query.amp ? { amp: '1' } : {}) } : parsedUrl.query, nowParams ? nowParams : params, _params, isFallback ? { __nextFallback: 'true' } : {}), renderOpts)\n\n        if (!renderMode) {\n          if (_nextData || getStaticProps || getServerSideProps) {\n            sendPayload(res, _nextData ? JSON.stringify(renderOpts.pageData) : result, _nextData ? 'json' : 'html', {\n              private: isPreviewMode,\n              stateful: !!getServerSideProps,\n              revalidate: renderOpts.revalidate,\n            })\n            return null\n          }\n        } else if (isPreviewMode) {\n          res.setHeader(\n            'Cache-Control',\n            'private, no-cache, no-store, max-age=0, must-revalidate'\n          )\n        }\n\n        if (renderMode) return { html: result, renderOpts }\n        return result\n      } catch (err) {\n        if (!parsedUrl) {\n          parsedUrl = parse(req.url, true)\n        }\n\n        if (err.code === 'ENOENT') {\n          res.statusCode = 404\n        } else if (err.code === 'DECODE_FAILED') {\n          res.statusCode = 400\n        } else {\n          console.error(err)\n          res.statusCode = 500\n        }\n\n        const result = await renderToHTML(req, res, \"/_error\", parsedUrl.query, Object.assign({}, options, {\n          getStaticProps: undefined,\n          getStaticPaths: undefined,\n          getServerSideProps: undefined,\n          Component: Error,\n          err: res.statusCode === 404 ? undefined : err\n        }))\n        return result\n      }\n    }\n    export async function render (req, res) {\n      try {\n        await initServer()\n        const html = await renderReqToHTML(req, res)\n        if (html) {\n          sendHTML(req, res, html, {generateEtags: ${generateEtags}})\n        }\n      } catch(err) {\n        await onError(err)\n        console.error(err)\n        res.statusCode = 500\n        res.end('Internal Server Error')\n      }\n    }\n  `\n  }\n}\n\nexport default nextServerlessLoader\n"]}