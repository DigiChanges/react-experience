{"version":3,"sources":["../../../../build/babel/plugins/next-ssg-transform.ts"],"names":["EXPORT_NAME_GET_STATIC_PROPS","EXPORT_NAME_GET_STATIC_PATHS","EXPORT_NAME_GET_SERVER_PROPS","ssgExports","Set","decorateSsgExport","t","path","state","gsspName","isPrerender","STATIC_PROPS_ID","SERVER_PROPS_ID","gsspId","identifier","addGsspExport","done","pageCompPath","replaceWithMultiple","exportNamedDeclaration","variableDeclaration","variableDeclarator","booleanLiteral","exportSpecifier","node","scope","registerDeclaration","traverse","ExportDefaultDeclaration","ExportNamedDeclaration","isDataIdentifier","name","has","Error","SERVER_PROPS_SSG_CONFLICT","isServerProps","nextTransformSsg","types","getIdentifier","parentPath","type","pp","get","id","isIdentifierReferenced","ident","b","getBinding","referenced","constantViolations","concat","referencePaths","every","ref","findParent","p","markFunction","refs","add","markImport","local","visitor","Program","enter","VariableDeclarator","pattern","properties","forEach","elements","e","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","specifiers","length","s","exported","remove","decl","inner","d","count","sweepFunction","isAssignmentExpression","isVariableDeclarator","sweepImport","parent","crawl","beforeCount"],"mappings":"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","sourcesContent":["import { NodePath, PluginObj, types as BabelTypes } from '@babel/core'\nimport { SERVER_PROPS_SSG_CONFLICT } from '../../../lib/constants'\nimport {\n  SERVER_PROPS_ID,\n  STATIC_PROPS_ID,\n} from '../../../next-server/lib/constants'\n\nexport const EXPORT_NAME_GET_STATIC_PROPS = 'getStaticProps'\nexport const EXPORT_NAME_GET_STATIC_PATHS = 'getStaticPaths'\nexport const EXPORT_NAME_GET_SERVER_PROPS = 'getServerSideProps'\n\nconst ssgExports = new Set([\n  EXPORT_NAME_GET_STATIC_PROPS,\n  EXPORT_NAME_GET_STATIC_PATHS,\n  EXPORT_NAME_GET_SERVER_PROPS,\n\n  // legacy methods added so build doesn't fail from importing\n  // server-side only methods\n  `unstable_getStaticProps`,\n  `unstable_getStaticPaths`,\n  `unstable_getServerProps`,\n  `unstable_getServerSideProps`,\n])\n\ntype PluginState = {\n  refs: Set<NodePath<BabelTypes.Identifier>>\n  isPrerender: boolean\n  isServerProps: boolean\n  done: boolean\n}\n\nfunction decorateSsgExport(\n  t: typeof BabelTypes,\n  path: NodePath<BabelTypes.Program>,\n  state: PluginState\n): void {\n  const gsspName = state.isPrerender ? STATIC_PROPS_ID : SERVER_PROPS_ID\n  const gsspId = t.identifier(gsspName)\n\n  const addGsspExport = (\n    path: NodePath<\n      BabelTypes.ExportDefaultDeclaration | BabelTypes.ExportNamedDeclaration\n    >\n  ): void => {\n    if (state.done) {\n      return\n    }\n    state.done = true\n\n    // @ts-ignore invalid return type\n    const [pageCompPath] = path.replaceWithMultiple([\n      t.exportNamedDeclaration(\n        t.variableDeclaration(\n          // We use 'var' instead of 'let' or 'const' for ES5 support. Since\n          // this runs in `Program#exit`, no ES2015 transforms (preset env)\n          // will be ran against this code.\n          'var',\n          [t.variableDeclarator(gsspId, t.booleanLiteral(true))]\n        ),\n        [t.exportSpecifier(gsspId, gsspId)]\n      ),\n      path.node,\n    ])\n    path.scope.registerDeclaration(pageCompPath)\n  }\n\n  path.traverse({\n    ExportDefaultDeclaration(path) {\n      addGsspExport(path)\n    },\n    ExportNamedDeclaration(path) {\n      addGsspExport(path)\n    },\n  })\n}\n\nconst isDataIdentifier = (name: string, state: PluginState): boolean => {\n  if (ssgExports.has(name)) {\n    if (name === EXPORT_NAME_GET_SERVER_PROPS) {\n      if (state.isPrerender) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n      state.isServerProps = true\n    } else {\n      if (state.isServerProps) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n      state.isPrerender = true\n    }\n    return true\n  }\n  return false\n}\n\nexport default function nextTransformSsg({\n  types: t,\n}: {\n  types: typeof BabelTypes\n}): PluginObj<PluginState> {\n  function getIdentifier(\n    path: NodePath<\n      | BabelTypes.FunctionDeclaration\n      | BabelTypes.FunctionExpression\n      | BabelTypes.ArrowFunctionExpression\n    >\n  ): NodePath<BabelTypes.Identifier> | null {\n    const parentPath = path.parentPath\n    if (parentPath.type === 'VariableDeclarator') {\n      const pp = parentPath as NodePath<BabelTypes.VariableDeclarator>\n      const name = pp.get('id')\n      return name.node.type === 'Identifier'\n        ? (name as NodePath<BabelTypes.Identifier>)\n        : null\n    }\n\n    if (parentPath.type === 'AssignmentExpression') {\n      const pp = parentPath as NodePath<BabelTypes.AssignmentExpression>\n      const name = pp.get('left')\n      return name.node.type === 'Identifier'\n        ? (name as NodePath<BabelTypes.Identifier>)\n        : null\n    }\n\n    if (path.node.type === 'ArrowFunctionExpression') {\n      return null\n    }\n\n    return path.node.id && path.node.id.type === 'Identifier'\n      ? (path.get('id') as NodePath<BabelTypes.Identifier>)\n      : null\n  }\n\n  function isIdentifierReferenced(\n    ident: NodePath<BabelTypes.Identifier>\n  ): boolean {\n    const b = ident.scope.getBinding(ident.node.name)\n    if (b?.referenced) {\n      // Functions can reference themselves, so we need to check if there's a\n      // binding outside the function scope or not.\n      if (b.path.type === 'FunctionDeclaration') {\n        return !b.constantViolations\n          .concat(b.referencePaths)\n          // Check that every reference is contained within the function:\n          .every((ref) => ref.findParent((p) => p === b.path))\n      }\n\n      return true\n    }\n    return false\n  }\n\n  function markFunction(\n    path: NodePath<\n      | BabelTypes.FunctionDeclaration\n      | BabelTypes.FunctionExpression\n      | BabelTypes.ArrowFunctionExpression\n    >,\n    state: PluginState\n  ): void {\n    const ident = getIdentifier(path)\n    if (ident?.node && isIdentifierReferenced(ident)) {\n      state.refs.add(ident)\n    }\n  }\n\n  function markImport(\n    path: NodePath<\n      | BabelTypes.ImportSpecifier\n      | BabelTypes.ImportDefaultSpecifier\n      | BabelTypes.ImportNamespaceSpecifier\n    >,\n    state: PluginState\n  ): void {\n    const local = path.get('local')\n    if (isIdentifierReferenced(local)) {\n      state.refs.add(local)\n    }\n  }\n\n  return {\n    visitor: {\n      Program: {\n        enter(path, state) {\n          state.refs = new Set<NodePath<BabelTypes.Identifier>>()\n          state.isPrerender = false\n          state.isServerProps = false\n          state.done = false\n\n          path.traverse(\n            {\n              VariableDeclarator(path, state) {\n                if (path.node.id.type === 'Identifier') {\n                  const local = path.get('id') as NodePath<\n                    BabelTypes.Identifier\n                  >\n                  if (isIdentifierReferenced(local)) {\n                    state.refs.add(local)\n                  }\n                } else if (path.node.id.type === 'ObjectPattern') {\n                  const pattern = path.get('id') as NodePath<\n                    BabelTypes.ObjectPattern\n                  >\n\n                  const properties = pattern.get('properties')\n                  properties.forEach((p) => {\n                    const local = p.get(\n                      p.node.type === 'ObjectProperty'\n                        ? 'value'\n                        : p.node.type === 'RestElement'\n                        ? 'argument'\n                        : (function () {\n                            throw new Error('invariant')\n                          })()\n                    ) as NodePath<BabelTypes.Identifier>\n                    if (isIdentifierReferenced(local)) {\n                      state.refs.add(local)\n                    }\n                  })\n                } else if (path.node.id.type === 'ArrayPattern') {\n                  const pattern = path.get('id') as NodePath<\n                    BabelTypes.ArrayPattern\n                  >\n\n                  const elements = pattern.get('elements')\n                  elements.forEach((e) => {\n                    let local: NodePath<BabelTypes.Identifier>\n                    if (e.node?.type === 'Identifier') {\n                      local = e as NodePath<BabelTypes.Identifier>\n                    } else if (e.node?.type === 'RestElement') {\n                      local = e.get('argument') as NodePath<\n                        BabelTypes.Identifier\n                      >\n                    } else {\n                      return\n                    }\n\n                    if (isIdentifierReferenced(local)) {\n                      state.refs.add(local)\n                    }\n                  })\n                }\n              },\n              FunctionDeclaration: markFunction,\n              FunctionExpression: markFunction,\n              ArrowFunctionExpression: markFunction,\n              ImportSpecifier: markImport,\n              ImportDefaultSpecifier: markImport,\n              ImportNamespaceSpecifier: markImport,\n              ExportNamedDeclaration(path, state) {\n                const specifiers = path.get('specifiers')\n                if (specifiers.length) {\n                  specifiers.forEach((s) => {\n                    if (isDataIdentifier(s.node.exported.name, state)) {\n                      s.remove()\n                    }\n                  })\n\n                  if (path.node.specifiers.length < 1) {\n                    path.remove()\n                  }\n                  return\n                }\n\n                const decl = path.get('declaration') as NodePath<\n                  | BabelTypes.FunctionDeclaration\n                  | BabelTypes.VariableDeclaration\n                >\n                if (decl == null || decl.node == null) {\n                  return\n                }\n\n                switch (decl.node.type) {\n                  case 'FunctionDeclaration': {\n                    const name = decl.node.id!.name\n                    if (isDataIdentifier(name, state)) {\n                      path.remove()\n                    }\n                    break\n                  }\n                  case 'VariableDeclaration': {\n                    const inner = decl.get('declarations') as NodePath<\n                      BabelTypes.VariableDeclarator\n                    >[]\n                    inner.forEach((d) => {\n                      if (d.node.id.type !== 'Identifier') {\n                        return\n                      }\n                      const name = d.node.id.name\n                      if (isDataIdentifier(name, state)) {\n                        d.remove()\n                      }\n                    })\n                    break\n                  }\n                  default: {\n                    break\n                  }\n                }\n              },\n            },\n            state\n          )\n\n          if (!state.isPrerender && !state.isServerProps) {\n            return\n          }\n\n          const refs = state.refs\n          let count: number\n\n          function sweepFunction(\n            path: NodePath<\n              | BabelTypes.FunctionDeclaration\n              | BabelTypes.FunctionExpression\n              | BabelTypes.ArrowFunctionExpression\n            >\n          ): void {\n            const ident = getIdentifier(path)\n            if (\n              ident?.node &&\n              refs.has(ident) &&\n              !isIdentifierReferenced(ident)\n            ) {\n              ++count\n\n              if (\n                t.isAssignmentExpression(path.parentPath) ||\n                t.isVariableDeclarator(path.parentPath)\n              ) {\n                path.parentPath.remove()\n              } else {\n                path.remove()\n              }\n            }\n          }\n\n          function sweepImport(\n            path: NodePath<\n              | BabelTypes.ImportSpecifier\n              | BabelTypes.ImportDefaultSpecifier\n              | BabelTypes.ImportNamespaceSpecifier\n            >\n          ): void {\n            const local = path.get('local')\n            if (refs.has(local) && !isIdentifierReferenced(local)) {\n              ++count\n              path.remove()\n              if (\n                (path.parent as BabelTypes.ImportDeclaration).specifiers\n                  .length === 0\n              ) {\n                path.parentPath.remove()\n              }\n            }\n          }\n\n          do {\n            ;(path.scope as any).crawl()\n            count = 0\n\n            path.traverse({\n              // eslint-disable-next-line no-loop-func\n              VariableDeclarator(path) {\n                if (path.node.id.type === 'Identifier') {\n                  const local = path.get('id') as NodePath<\n                    BabelTypes.Identifier\n                  >\n                  if (refs.has(local) && !isIdentifierReferenced(local)) {\n                    ++count\n                    path.remove()\n                  }\n                } else if (path.node.id.type === 'ObjectPattern') {\n                  const pattern = path.get('id') as NodePath<\n                    BabelTypes.ObjectPattern\n                  >\n\n                  const beforeCount = count\n                  const properties = pattern.get('properties')\n                  properties.forEach((p) => {\n                    const local = p.get(\n                      p.node.type === 'ObjectProperty'\n                        ? 'value'\n                        : p.node.type === 'RestElement'\n                        ? 'argument'\n                        : (function () {\n                            throw new Error('invariant')\n                          })()\n                    ) as NodePath<BabelTypes.Identifier>\n\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count\n                      p.remove()\n                    }\n                  })\n\n                  if (\n                    beforeCount !== count &&\n                    pattern.get('properties').length < 1\n                  ) {\n                    path.remove()\n                  }\n                } else if (path.node.id.type === 'ArrayPattern') {\n                  const pattern = path.get('id') as NodePath<\n                    BabelTypes.ArrayPattern\n                  >\n\n                  const beforeCount = count\n                  const elements = pattern.get('elements')\n                  elements.forEach((e) => {\n                    let local: NodePath<BabelTypes.Identifier>\n                    if (e.node?.type === 'Identifier') {\n                      local = e as NodePath<BabelTypes.Identifier>\n                    } else if (e.node?.type === 'RestElement') {\n                      local = e.get('argument') as NodePath<\n                        BabelTypes.Identifier\n                      >\n                    } else {\n                      return\n                    }\n\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count\n                      e.remove()\n                    }\n                  })\n\n                  if (\n                    beforeCount !== count &&\n                    pattern.get('elements').length < 1\n                  ) {\n                    path.remove()\n                  }\n                }\n              },\n              FunctionDeclaration: sweepFunction,\n              FunctionExpression: sweepFunction,\n              ArrowFunctionExpression: sweepFunction,\n              ImportSpecifier: sweepImport,\n              ImportDefaultSpecifier: sweepImport,\n              ImportNamespaceSpecifier: sweepImport,\n            })\n          } while (count)\n\n          decorateSsgExport(t, path, state)\n        },\n      },\n    },\n  }\n}\n"]}