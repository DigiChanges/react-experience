{"version":3,"sources":["../../lib/check-custom-routes.ts"],"names":["allowedStatusCodes","Set","getRedirectStatus","route","statusCode","permanent","PERMANENT_REDIRECT_STATUS","TEMPORARY_REDIRECT_STATUS","checkRedirect","invalidParts","hadInvalidStatus","has","push","checkHeader","Array","isArray","headers","header","key","value","tryParsePath","handleUrl","result","routePath","parsedDestination","pathname","hash","tokens","pathToRegexp","parse","tokensToRegexp","err","errMatches","message","match","position","parseInt","console","error","fill","join","checkCustomRoutes","routes","type","Error","numInvalidRoutes","isRedirect","allowedKeys","JSON","stringify","keys","Object","invalidKeys","filter","source","startsWith","_route","destination","sourceTokens","unnamedInDest","token","name","unnamedIndex","RegExp","add","size","destTokens","destinationParseFailed","sourceSegments","map","item","Boolean","invalidDestSegments","hasInvalidKeys","length","hasInvalidParts"],"mappings":"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","sourcesContent":["import * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport { parse as parseUrl } from 'url'\nimport {\n  PERMANENT_REDIRECT_STATUS,\n  TEMPORARY_REDIRECT_STATUS,\n} from '../next-server/lib/constants'\n\nexport type Rewrite = {\n  source: string\n  destination: string\n}\n\nexport type Redirect = Rewrite & {\n  statusCode?: number\n  permanent?: boolean\n}\n\nexport type Header = {\n  source: string\n  headers: Array<{ key: string; value: string }>\n}\n\nconst allowedStatusCodes = new Set([301, 302, 303, 307, 308])\n\nexport function getRedirectStatus(route: Redirect): number {\n  return (\n    route.statusCode ||\n    (route.permanent ? PERMANENT_REDIRECT_STATUS : TEMPORARY_REDIRECT_STATUS)\n  )\n}\n\nfunction checkRedirect(\n  route: Redirect\n): { invalidParts: string[]; hadInvalidStatus: boolean } {\n  const invalidParts: string[] = []\n  let hadInvalidStatus: boolean = false\n\n  if (route.statusCode && !allowedStatusCodes.has(route.statusCode)) {\n    hadInvalidStatus = true\n    invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`)\n  }\n  if (typeof route.permanent !== 'boolean' && !route.statusCode) {\n    invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``)\n  }\n\n  return {\n    invalidParts,\n    hadInvalidStatus,\n  }\n}\n\nfunction checkHeader(route: Header): string[] {\n  const invalidParts: string[] = []\n\n  if (!Array.isArray(route.headers)) {\n    invalidParts.push('`headers` field must be an array')\n  } else {\n    for (const header of route.headers) {\n      if (!header || typeof header !== 'object') {\n        invalidParts.push(\n          \"`headers` items must be object with { key: '', value: '' }\"\n        )\n        break\n      }\n      if (typeof header.key !== 'string') {\n        invalidParts.push('`key` in header item must be string')\n        break\n      }\n      if (typeof header.value !== 'string') {\n        invalidParts.push('`value` in header item must be string')\n        break\n      }\n    }\n  }\n  return invalidParts\n}\n\ntype ParseAttemptResult = {\n  error?: boolean\n  tokens?: pathToRegexp.Token[]\n}\n\nfunction tryParsePath(route: string, handleUrl?: boolean): ParseAttemptResult {\n  const result: ParseAttemptResult = {}\n  let routePath = route\n\n  try {\n    if (handleUrl) {\n      const parsedDestination = parseUrl(route, true)\n      routePath = `${parsedDestination.pathname!}${\n        parsedDestination.hash || ''\n      }`\n    }\n\n    // Make sure we can parse the source properly\n    result.tokens = pathToRegexp.parse(routePath)\n    pathToRegexp.tokensToRegexp(result.tokens)\n  } catch (err) {\n    // If there is an error show our err.sh but still show original error or a formatted one if we can\n    const errMatches = err.message.match(/at (\\d{0,})/)\n\n    if (errMatches) {\n      const position = parseInt(errMatches[1], 10)\n      console.error(\n        `\\nError parsing \\`${route}\\` ` +\n          `https://err.sh/vercel/next.js/invalid-route-source\\n` +\n          `Reason: ${err.message}\\n\\n` +\n          `  ${routePath}\\n` +\n          `  ${new Array(position).fill(' ').join('')}^\\n`\n      )\n    } else {\n      console.error(\n        `\\nError parsing ${route} https://err.sh/vercel/next.js/invalid-route-source`,\n        err\n      )\n    }\n    result.error = true\n  }\n\n  return result\n}\n\nexport type RouteType = 'rewrite' | 'redirect' | 'header'\n\nexport default function checkCustomRoutes(\n  routes: Redirect[] | Header[] | Rewrite[],\n  type: RouteType\n): void {\n  if (!Array.isArray(routes)) {\n    throw new Error(\n      `${type}s must return an array, received ${typeof routes}.\\n` +\n        `See here for more info: https://err.sh/next.js/routes-must-be-array`\n    )\n  }\n\n  let numInvalidRoutes = 0\n  let hadInvalidStatus = false\n\n  const isRedirect = type === 'redirect'\n  let allowedKeys: Set<string>\n\n  if (type === 'rewrite' || isRedirect) {\n    allowedKeys = new Set([\n      'source',\n      'destination',\n      ...(isRedirect ? ['statusCode', 'permanent'] : []),\n    ])\n  } else {\n    allowedKeys = new Set(['source', 'headers'])\n  }\n\n  for (const route of routes) {\n    if (!route || typeof route !== 'object') {\n      console.error(\n        `The route ${JSON.stringify(\n          route\n        )} is not a valid object with \\`source\\` and \\`${\n          type === 'header' ? 'headers' : 'destination'\n        }\\``\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    const keys = Object.keys(route)\n    const invalidKeys = keys.filter((key) => !allowedKeys.has(key))\n    const invalidParts: string[] = []\n\n    if (!route.source) {\n      invalidParts.push('`source` is missing')\n    } else if (typeof route.source !== 'string') {\n      invalidParts.push('`source` is not a string')\n    } else if (!route.source.startsWith('/')) {\n      invalidParts.push('`source` does not start with /')\n    }\n\n    if (type === 'header') {\n      invalidParts.push(...checkHeader(route as Header))\n    } else {\n      let _route = route as Rewrite | Redirect\n      if (!_route.destination) {\n        invalidParts.push('`destination` is missing')\n      } else if (typeof _route.destination !== 'string') {\n        invalidParts.push('`destination` is not a string')\n      } else if (\n        type === 'rewrite' &&\n        !_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)\n      ) {\n        invalidParts.push(\n          '`destination` does not start with `/`, `http://`, or `https://`'\n        )\n      }\n    }\n\n    if (type === 'redirect') {\n      const result = checkRedirect(route as Redirect)\n      hadInvalidStatus = hadInvalidStatus || result.hadInvalidStatus\n      invalidParts.push(...result.invalidParts)\n    }\n\n    let sourceTokens: pathToRegexp.Token[] | undefined\n\n    if (typeof route.source === 'string' && route.source.startsWith('/')) {\n      // only show parse error if we didn't already show error\n      // for not being a string\n      const { tokens, error } = tryParsePath(route.source)\n\n      if (error) {\n        invalidParts.push('`source` parse failed')\n      }\n      sourceTokens = tokens\n    }\n\n    // make sure no unnamed patterns are attempted to be used in the\n    // destination as this can cause confusion and is not allowed\n    if (typeof (route as Rewrite).destination === 'string') {\n      if (\n        (route as Rewrite).destination.startsWith('/') &&\n        Array.isArray(sourceTokens)\n      ) {\n        const unnamedInDest = new Set()\n\n        for (const token of sourceTokens) {\n          if (typeof token === 'object' && typeof token.name === 'number') {\n            const unnamedIndex = new RegExp(`:${token.name}(?!\\\\d)`)\n            if ((route as Rewrite).destination.match(unnamedIndex)) {\n              unnamedInDest.add(`:${token.name}`)\n            }\n          }\n        }\n\n        if (unnamedInDest.size > 0) {\n          invalidParts.push(\n            `\\`destination\\` has unnamed params ${[...unnamedInDest].join(\n              ', '\n            )}`\n          )\n        } else {\n          const {\n            tokens: destTokens,\n            error: destinationParseFailed,\n          } = tryParsePath((route as Rewrite).destination, true)\n\n          if (destinationParseFailed) {\n            invalidParts.push('`destination` parse failed')\n          } else {\n            const sourceSegments = new Set(\n              sourceTokens\n                .map((item) => typeof item === 'object' && item.name)\n                .filter(Boolean)\n            )\n            const invalidDestSegments = new Set()\n\n            for (const token of destTokens!) {\n              if (\n                typeof token === 'object' &&\n                !sourceSegments.has(token.name)\n              ) {\n                invalidDestSegments.add(token.name)\n              }\n            }\n\n            if (invalidDestSegments.size) {\n              invalidParts.push(\n                `\\`destination\\` has segments not in \\`source\\` (${[\n                  ...invalidDestSegments,\n                ].join(', ')})`\n              )\n            }\n          }\n        }\n      }\n    }\n\n    const hasInvalidKeys = invalidKeys.length > 0\n    const hasInvalidParts = invalidParts.length > 0\n\n    if (hasInvalidKeys || hasInvalidParts) {\n      console.error(\n        `${invalidParts.join(', ')}${\n          invalidKeys.length\n            ? (hasInvalidParts ? ',' : '') +\n              ` invalid field${invalidKeys.length === 1 ? '' : 's'}: ` +\n              invalidKeys.join(',')\n            : ''\n        } for route ${JSON.stringify(route)}`\n      )\n      numInvalidRoutes++\n    }\n  }\n\n  if (numInvalidRoutes > 0) {\n    if (hadInvalidStatus) {\n      console.error(\n        `\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(\n          ', '\n        )}`\n      )\n    }\n    console.error()\n\n    throw new Error(`Invalid ${type}${numInvalidRoutes === 1 ? '' : 's'} found`)\n  }\n}\n"]}