{"version":3,"sources":["../../../next-server/server/router.ts"],"names":["route","prepareDestination","destination","params","query","appendParamsToQuery","parsedDestination","destQuery","destinationCompiler","pathname","hash","validate","newUrl","key","strOrArray","Object","entries","value","Array","isArray","queryCompiler","substr","name","encodeURI","split","path","search","err","message","match","Error","Router","constructor","headers","fsRoutes","rewrites","redirects","catchAllRoute","dynamicRoutes","pageChecker","useFileSystemPublicRoutes","setDynamicRoutes","routes","addFsRoute","unshift","execute","req","res","parsedUrl","pageChecks","memoizedPageChecker","p","result","parsedUrlUpdated","type","fn","finished","newParams","check","fsRoute","fsParams","matchedPage","dynamicRoute","pageParams"],"mappings":"qGACA,wBAEA,+DACA,mE,mFAEO,KAAMA,CAAAA,KAAK,CAAG,wBAAd,C,oBA8BA,KAAMC,CAAAA,kBAAkB,CAAG,CAChCC,WADgC,CAEhCC,MAFgC,CAGhCC,KAHgC,CAIhCC,mBAJgC,GAK7B,CACH,KAAMC,CAAAA,iBAAiB,CAAG,eAASJ,WAAT,CAAsB,IAAtB,CAA1B,CACA,KAAMK,CAAAA,SAAS,CAAGD,iBAAiB,CAACF,KAApC,CACA,GAAII,CAAAA,mBAAmB,CAAG,0BACvB,GAAEF,iBAAiB,CAACG,QAAU,GAAEH,iBAAiB,CAACI,IAAlB,EAA0B,EAAG,EADtC,CAExB;AACA;AACA;AACA;AACA;AACA;AACA,CAAEC,QAAQ,CAAE,KAAZ,CARwB,CAA1B,CAUA,GAAIC,CAAAA,MAAJ,CAEA;AACA,IAAK,KAAM,CAACC,GAAD,CAAMC,UAAN,CAAX,EAAgCC,CAAAA,MAAM,CAACC,OAAP,CAAeT,SAAf,CAAhC,CAA2D,CACzD,GAAIU,CAAAA,KAAK,CAAGC,KAAK,CAACC,OAAN,CAAcL,UAAd,EAA4BA,UAAU,CAAC,CAAD,CAAtC,CAA4CA,UAAxD,CACA,GAAIG,KAAJ,CAAW,CACT;AACA;AACAA,KAAK,CAAI,IAAGA,KAAM,EAAlB,CACA,KAAMG,CAAAA,aAAa,CAAG,0BAAmBH,KAAnB,CAA0B,CAAEN,QAAQ,CAAE,KAAZ,CAA1B,CAAtB,CACAM,KAAK,CAAGG,aAAa,CAACjB,MAAD,CAAb,CAAsBkB,MAAtB,CAA6B,CAA7B,CAAR,CACD,CACDd,SAAS,CAACM,GAAD,CAAT,CAAiBI,KAAjB,CACD,CAED;AACA;AACA,GAAIZ,mBAAJ,CAAyB,CACvB,IAAK,KAAM,CAACiB,IAAD,CAAOL,KAAP,CAAX,EAA4BF,CAAAA,MAAM,CAACC,OAAP,CAAeb,MAAf,CAA5B,CAAoD,CAClD,GAAI,EAAEmB,IAAI,GAAIf,CAAAA,SAAV,CAAJ,CAA0B,CACxBA,SAAS,CAACe,IAAD,CAAT,CAAkBL,KAAlB,CACD,CACF,CACF,CAED,GAAI,CACFL,MAAM,CAAGW,SAAS,CAACf,mBAAmB,CAACL,MAAD,CAApB,CAAlB,CAEA,KAAM,CAACM,QAAD,CAAWC,IAAX,EAAmBE,MAAM,CAACY,KAAP,CAAa,GAAb,CAAzB,CACAlB,iBAAiB,CAACG,QAAlB,CAA6BA,QAA7B,CACAH,iBAAiB,CAACI,IAAlB,CAA0B,GAAEA,IAAI,CAAG,GAAH,CAAS,EAAG,GAAEA,IAAI,EAAI,EAAG,EAAzD,CACAJ,iBAAiB,CAACmB,IAAlB,CAA0B,GAAEhB,QAAS,GAAEH,iBAAiB,CAACoB,MAAO,EAAhE,CACA,MAAOpB,CAAAA,iBAAiB,CAACoB,MAAzB,CACD,CAAC,MAAOC,GAAP,CAAY,CACZ,GAAIA,GAAG,CAACC,OAAJ,CAAYC,KAAZ,CAAkB,8CAAlB,CAAJ,CAAuE,CACrE,KAAM,IAAIC,CAAAA,KAAJ,CACH,wKADG,CAAN,CAGD,CACD,KAAMH,CAAAA,GAAN,CACD,CAED;AACA;AACA;AACA;AACArB,iBAAiB,CAACF,KAAlB,CAA0B,CACxB,GAAGA,KADqB,CAExB,GAAGE,iBAAiB,CAACF,KAFG,CAA1B,CAKA,MAAO,CACLQ,MADK,CAELN,iBAFK,CAAP,CAID,CAzEM,C,8CA2EQ,KAAMyB,CAAAA,MAAO,CAU1BC,WAAW,CAAC,CACVC,OAAO,CAAG,EADA,CAEVC,QAAQ,CAAG,EAFD,CAGVC,QAAQ,CAAG,EAHD,CAIVC,SAAS,CAAG,EAJF,CAKVC,aALU,CAMVC,aAAa,CAAG,EANN,CAOVC,WAPU,CAQVC,yBARU,CAAD,CAkBR,MA3BHP,OA2BG,aA1BHC,QA0BG,aAzBHC,QAyBG,aAxBHC,SAwBG,aAvBHC,aAuBG,aAtBHE,WAsBG,aArBHD,aAqBG,aApBHE,yBAoBG,QACD,KAAKP,OAAL,CAAeA,OAAf,CACA,KAAKC,QAAL,CAAgBA,QAAhB,CACA,KAAKC,QAAL,CAAgBA,QAAhB,CACA,KAAKC,SAAL,CAAiBA,SAAjB,CACA,KAAKG,WAAL,CAAmBA,WAAnB,CACA,KAAKF,aAAL,CAAqBA,aAArB,CACA,KAAKC,aAAL,CAAqBA,aAArB,CACA,KAAKE,yBAAL,CAAiCA,yBAAjC,CACD,CAEDC,gBAAgB,CAACC,MAAqB,CAAG,EAAzB,CAA6B,CAC3C,KAAKJ,aAAL,CAAqBI,MAArB,CACD,CAEDC,UAAU,CAAC3C,KAAD,CAAe,CACvB,KAAKkC,QAAL,CAAcU,OAAd,CAAsB5C,KAAtB,EACD,CAED,KAAM6C,CAAAA,OAAN,CACEC,GADF,CAEEC,GAFF,CAGEC,SAHF,CAIoB,CAClB;AACA,KAAMC,CAAAA,UAAgD,CAAG,EAAzD,CACA,KAAMC,CAAAA,mBAAmB,CAAG,KAAOC,CAAAA,CAAP,EAAuC,CACjE,GAAIF,UAAU,CAACE,CAAD,CAAd,CAAmB,CACjB,MAAOF,CAAAA,UAAU,CAACE,CAAD,CAAjB,CACD,CACD,KAAMC,CAAAA,MAAM,CAAG,KAAKb,WAAL,CAAiBY,CAAjB,CAAf,CACAF,UAAU,CAACE,CAAD,CAAV,CAAgBC,MAAhB,CACA,MAAOA,CAAAA,MAAP,CACD,CAPD,CASA,GAAIC,CAAAA,gBAAgB,CAAGL,SAAvB,CAEA;;;;;;MAQA,KAAMN,CAAAA,MAAM,CAAG,CACb,GAAG,KAAKT,OADK,CAEb,GAAG,KAAKG,SAFK,CAGb,GAAG,KAAKF,QAHK,CAIb;AACA;AACA,IAAI,KAAKM,yBAAL,CACA,CACE,CACEc,IAAI,CAAE,OADR,CAEEhC,IAAI,CAAE,cAFR,CAGEO,KAAK,CAAE7B,KAAK,CAAC,SAAD,CAHd,CAIEuD,EAAE,CAAE,MAAOT,GAAP,CAAYC,GAAZ,CAAiB5C,MAAjB,CAAyB6C,SAAzB,GAAuC,CACzC,KAAM,CAAEvC,QAAF,EAAeuC,SAArB,CAEA,GAAI,CAACvC,QAAL,CAAe,CACb,MAAO,CAAE+C,QAAQ,CAAE,KAAZ,CAAP,CACD,CACD,GAAI,KAAMN,CAAAA,mBAAmB,CAACzC,QAAD,CAA7B,CAAyC,CACvC,MAAO,MAAK4B,aAAL,CAAmBkB,EAAnB,CAAsBT,GAAtB,CAA2BC,GAA3B,CAAgC5C,MAAhC,CAAwC6C,SAAxC,CAAP,CACD,CACD,MAAO,CAAEQ,QAAQ,CAAE,KAAZ,CAAP,CACD,CAdH,CADF,CADA,CAmBA,EAnBJ,CANa,CA0Bb,GAAG,KAAKrB,QA1BK,CA2Bb;AACA;AACA,IAAI,KAAKK,yBAAL,CAAiC,CAAC,KAAKH,aAAN,CAAjC,CAAwD,EAA5D,CA7Ba,CAAf,CAgCA,IAAK,KAAMrC,CAAAA,KAAX,GAAoB0C,CAAAA,MAApB,CAA4B,CAC1B,KAAMe,CAAAA,SAAS,CAAGzD,KAAK,CAAC6B,KAAN,CAAYwB,gBAAgB,CAAC5C,QAA7B,CAAlB,CAEA;AACA,GAAIgD,SAAJ,CAAe,CACb,KAAML,CAAAA,MAAM,CAAG,KAAMpD,CAAAA,KAAK,CAACuD,EAAN,CAAST,GAAT,CAAcC,GAAd,CAAmBU,SAAnB,CAA8BJ,gBAA9B,CAArB,CAEA;AACA,GAAID,MAAM,CAACI,QAAX,CAAqB,CACnB,MAAO,KAAP,CACD,CAED,GAAIJ,MAAM,CAAC3C,QAAX,CAAqB,CACnB4C,gBAAgB,CAAC5C,QAAjB,CAA4B2C,MAAM,CAAC3C,QAAnC,CACD,CAED,GAAI2C,MAAM,CAAChD,KAAX,CAAkB,CAChBiD,gBAAgB,CAACjD,KAAjB,CAAyB,CACvB,GAAGiD,gBAAgB,CAACjD,KADG,CAEvB,GAAGgD,MAAM,CAAChD,KAFa,CAAzB,CAID,CAED;AACA,GAAIJ,KAAK,CAAC0D,KAAN,GAAgB,IAApB,CAA0B,CACxB,IAAK,KAAMC,CAAAA,OAAX,GAAsB,MAAKzB,QAA3B,CAAqC,CACnC,KAAM0B,CAAAA,QAAQ,CAAGD,OAAO,CAAC9B,KAAR,CAAcwB,gBAAgB,CAAC5C,QAA/B,CAAjB,CAEA,GAAImD,QAAJ,CAAc,CACZ,KAAMR,CAAAA,MAAM,CAAG,KAAMO,CAAAA,OAAO,CAACJ,EAAR,CACnBT,GADmB,CAEnBC,GAFmB,CAGnBa,QAHmB,CAInBP,gBAJmB,CAArB,CAOA,GAAID,MAAM,CAACI,QAAX,CAAqB,CACnB,MAAO,KAAP,CACD,CACF,CACF,CAED,GAAIK,CAAAA,WAAW,CAAG,KAAMX,CAAAA,mBAAmB,CACzCG,gBAAgB,CAAC5C,QADwB,CAA3C,CAIA;AACA,GAAI,CAACoD,WAAL,CAAkB,CAChB,IAAK,KAAMC,CAAAA,YAAX,GAA2B,MAAKxB,aAAhC,CAA+C,CAC7C,GAAIwB,YAAY,CAACjC,KAAb,CAAmBwB,gBAAgB,CAAC5C,QAApC,CAAJ,CAAmD,CACjDoD,WAAW,CAAG,IAAd,CACD,CACF,CACF,CAED;AACA,GAAIA,WAAJ,CAAiB,CACf,KAAME,CAAAA,UAAU,CAAG,KAAK1B,aAAL,CAAmBR,KAAnB,CACjBwB,gBAAgB,CAAC5C,QADA,CAAnB,CAIA,KAAM,MAAK4B,aAAL,CAAmBkB,EAAnB,CACJT,GADI,CAEJC,GAFI,CAGJgB,UAHI,CAIJV,gBAJI,CAAN,CAMA,MAAO,KAAP,CACD,CACF,CACF,CACF,CAED,MAAO,MAAP,CACD,CAnLyB,C","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { parse as parseUrl, UrlWithParsedQuery } from 'url'\nimport { ParsedUrlQuery } from 'querystring'\nimport { compile as compilePathToRegex } from 'next/dist/compiled/path-to-regexp'\nimport pathMatch from './lib/path-match'\n\nexport const route = pathMatch()\n\nexport type Params = { [param: string]: any }\n\nexport type RouteMatch = (pathname: string | null | undefined) => false | Params\n\ntype RouteResult = {\n  finished: boolean\n  pathname?: string\n  query?: { [k: string]: string }\n}\n\nexport type Route = {\n  match: RouteMatch\n  type: string\n  check?: boolean\n  statusCode?: number\n  name: string\n  fn: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    params: Params,\n    parsedUrl: UrlWithParsedQuery\n  ) => Promise<RouteResult> | RouteResult\n}\n\nexport type DynamicRoutes = Array<{ page: string; match: RouteMatch }>\n\nexport type PageChecker = (pathname: string) => Promise<boolean>\n\nexport const prepareDestination = (\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery?: boolean\n) => {\n  const parsedDestination = parseUrl(destination, true)\n  const destQuery = parsedDestination.query\n  let destinationCompiler = compilePathToRegex(\n    `${parsedDestination.pathname!}${parsedDestination.hash || ''}`,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = compilePathToRegex(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query\n  if (appendParamsToQuery) {\n    for (const [name, value] of Object.entries(params)) {\n      if (!(name in destQuery)) {\n        destQuery[name] = value\n      }\n    }\n  }\n\n  try {\n    newUrl = encodeURI(destinationCompiler(params))\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    parsedDestination.path = `${pathname}${parsedDestination.search}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n\nexport default class Router {\n  headers: Route[]\n  fsRoutes: Route[]\n  rewrites: Route[]\n  redirects: Route[]\n  catchAllRoute: Route\n  pageChecker: PageChecker\n  dynamicRoutes: DynamicRoutes\n  useFileSystemPublicRoutes: boolean\n\n  constructor({\n    headers = [],\n    fsRoutes = [],\n    rewrites = [],\n    redirects = [],\n    catchAllRoute,\n    dynamicRoutes = [],\n    pageChecker,\n    useFileSystemPublicRoutes,\n  }: {\n    headers: Route[]\n    fsRoutes: Route[]\n    rewrites: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    dynamicRoutes: DynamicRoutes | undefined\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n  }) {\n    this.headers = headers\n    this.fsRoutes = fsRoutes\n    this.rewrites = rewrites\n    this.redirects = redirects\n    this.pageChecker = pageChecker\n    this.catchAllRoute = catchAllRoute\n    this.dynamicRoutes = dynamicRoutes\n    this.useFileSystemPublicRoutes = useFileSystemPublicRoutes\n  }\n\n  setDynamicRoutes(routes: DynamicRoutes = []) {\n    this.dynamicRoutes = routes\n  }\n\n  addFsRoute(route: Route) {\n    this.fsRoutes.unshift(route)\n  }\n\n  async execute(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    // memoize page check calls so we don't duplicate checks for pages\n    const pageChecks: { [name: string]: Promise<boolean> } = {}\n    const memoizedPageChecker = async (p: string): Promise<boolean> => {\n      if (pageChecks[p]) {\n        return pageChecks[p]\n      }\n      const result = this.pageChecker(p)\n      pageChecks[p] = result\n      return result\n    }\n\n    let parsedUrlUpdated = parsedUrl\n\n    /*\n      Desired routes order\n      - headers\n      - redirects\n      - Check filesystem (including pages), if nothing found continue\n      - User rewrites (checking filesystem and pages each match)\n    */\n\n    const routes = [\n      ...this.headers,\n      ...this.redirects,\n      ...this.fsRoutes,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes\n        ? [\n            {\n              type: 'route',\n              name: 'Page checker',\n              match: route('/:path*'),\n              fn: async (req, res, params, parsedUrl) => {\n                const { pathname } = parsedUrl\n\n                if (!pathname) {\n                  return { finished: false }\n                }\n                if (await memoizedPageChecker(pathname)) {\n                  return this.catchAllRoute.fn(req, res, params, parsedUrl)\n                }\n                return { finished: false }\n              },\n            } as Route,\n          ]\n        : []),\n      ...this.rewrites,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes ? [this.catchAllRoute] : []),\n    ]\n\n    for (const route of routes) {\n      const newParams = route.match(parsedUrlUpdated.pathname)\n\n      // Check if the match function matched\n      if (newParams) {\n        const result = await route.fn(req, res, newParams, parsedUrlUpdated)\n\n        // The response was handled\n        if (result.finished) {\n          return true\n        }\n\n        if (result.pathname) {\n          parsedUrlUpdated.pathname = result.pathname\n        }\n\n        if (result.query) {\n          parsedUrlUpdated.query = {\n            ...parsedUrlUpdated.query,\n            ...result.query,\n          }\n        }\n\n        // check filesystem\n        if (route.check === true) {\n          for (const fsRoute of this.fsRoutes) {\n            const fsParams = fsRoute.match(parsedUrlUpdated.pathname)\n\n            if (fsParams) {\n              const result = await fsRoute.fn(\n                req,\n                res,\n                fsParams,\n                parsedUrlUpdated\n              )\n\n              if (result.finished) {\n                return true\n              }\n            }\n          }\n\n          let matchedPage = await memoizedPageChecker(\n            parsedUrlUpdated.pathname!\n          )\n\n          // If we didn't match a page check dynamic routes\n          if (!matchedPage) {\n            for (const dynamicRoute of this.dynamicRoutes) {\n              if (dynamicRoute.match(parsedUrlUpdated.pathname)) {\n                matchedPage = true\n              }\n            }\n          }\n\n          // Matched a page or dynamic route so render it using catchAllRoute\n          if (matchedPage) {\n            const pageParams = this.catchAllRoute.match(\n              parsedUrlUpdated.pathname\n            )\n\n            await this.catchAllRoute.fn(\n              req,\n              res,\n              pageParams as Params,\n              parsedUrlUpdated\n            )\n            return true\n          }\n        }\n      }\n    }\n\n    return false\n  }\n}\n"]}