{"version":3,"sources":["../../../next-server/server/spr-cache.ts"],"names":["toRoute","pathname","replace","cache","prerenderManifest","sprOptions","getSeedPath","ext","path","join","pagesDir","calculateRevalidate","curTime","Date","getTime","dev","initialRevalidateSeconds","routes","revalidateAfter","initializeSprCache","max","distDir","flushToDisk","version","dynamicRoutes","preview","JSON","parse","PRERENDER_MANIFEST","LRUCache","length","val","html","stringify","pageData","getFallback","page","promises","readFile","getSprCache","data","get","set","_","isStale","manifestEntry","curRevalidate","setSprCache","revalidateSeconds","dataRoute","posix","srcRoute","seedPath","mkdir","dirname","recursive","writeFile","error","console","warn"],"mappings":"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","sourcesContent":["import { promises, readFileSync } from 'fs'\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from 'path'\nimport { PrerenderManifest } from '../../build'\nimport { PRERENDER_MANIFEST } from '../lib/constants'\nimport { normalizePagePath } from './normalize-page-path'\n\nfunction toRoute(pathname: string): string {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/'\n}\n\ntype SprCacheValue = {\n  html: string\n  pageData: any\n  isStale?: boolean\n  curRevalidate?: number | false\n  // milliseconds to revalidate after\n  revalidateAfter: number | false\n}\n\nlet cache: LRUCache<string, SprCacheValue>\nlet prerenderManifest: PrerenderManifest\nlet sprOptions: {\n  flushToDisk?: boolean\n  pagesDir?: string\n  distDir?: string\n  dev?: boolean\n} = {}\n\nconst getSeedPath = (pathname: string, ext: string): string => {\n  return path.join(sprOptions.pagesDir!, `${pathname}.${ext}`)\n}\n\nexport const calculateRevalidate = (pathname: string): number | false => {\n  pathname = toRoute(pathname)\n\n  // in development we don't have a prerender-manifest\n  // and default to always revalidating to allow easier debugging\n  const curTime = new Date().getTime()\n  if (sprOptions.dev) return curTime - 1000\n\n  const { initialRevalidateSeconds } = prerenderManifest.routes[pathname] || {\n    initialRevalidateSeconds: 1,\n  }\n  const revalidateAfter =\n    typeof initialRevalidateSeconds === 'number'\n      ? initialRevalidateSeconds * 1000 + curTime\n      : initialRevalidateSeconds\n\n  return revalidateAfter\n}\n\n// initialize the SPR cache\nexport function initializeSprCache({\n  max,\n  dev,\n  distDir,\n  pagesDir,\n  flushToDisk,\n}: {\n  dev: boolean\n  max?: number\n  distDir: string\n  pagesDir: string\n  flushToDisk?: boolean\n}) {\n  sprOptions = {\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk:\n      !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true),\n  }\n\n  if (dev) {\n    prerenderManifest = {\n      version: -1 as any, // letting us know this doesn't conform to spec\n      routes: {},\n      dynamicRoutes: {},\n      preview: null as any, // `preview` is special case read in next-dev-server\n    }\n  } else {\n    prerenderManifest = JSON.parse(\n      readFileSync(path.join(distDir, PRERENDER_MANIFEST), 'utf8')\n    )\n  }\n\n  cache = new LRUCache({\n    // default to 50MB limit\n    max: max || 50 * 1024 * 1024,\n    length(val) {\n      // rough estimate of size of cache value\n      return val.html.length + JSON.stringify(val.pageData).length\n    },\n  })\n}\n\nexport async function getFallback(page: string): Promise<string> {\n  page = normalizePagePath(page)\n  return promises.readFile(getSeedPath(page, 'html'), 'utf8')\n}\n\n// get data from SPR cache if available\nexport async function getSprCache(\n  pathname: string\n): Promise<SprCacheValue | undefined> {\n  if (sprOptions.dev) return\n  pathname = normalizePagePath(pathname)\n\n  let data: SprCacheValue | undefined = cache.get(pathname)\n\n  // let's check the disk for seed data\n  if (!data) {\n    try {\n      const html = await promises.readFile(\n        getSeedPath(pathname, 'html'),\n        'utf8'\n      )\n      const pageData = JSON.parse(\n        await promises.readFile(getSeedPath(pathname, 'json'), 'utf8')\n      )\n\n      data = {\n        html,\n        pageData,\n        revalidateAfter: calculateRevalidate(pathname),\n      }\n      cache.set(pathname, data)\n    } catch (_) {\n      // unable to get data from disk\n    }\n  }\n\n  if (\n    data &&\n    data.revalidateAfter !== false &&\n    data.revalidateAfter < new Date().getTime()\n  ) {\n    data.isStale = true\n  }\n  const manifestEntry = prerenderManifest.routes[pathname]\n\n  if (data && manifestEntry) {\n    data.curRevalidate = manifestEntry.initialRevalidateSeconds\n  }\n  return data\n}\n\n// populate the SPR cache with new data\nexport async function setSprCache(\n  pathname: string,\n  data: {\n    html: string\n    pageData: any\n  },\n  revalidateSeconds?: number | false\n) {\n  if (sprOptions.dev) return\n  if (typeof revalidateSeconds !== 'undefined') {\n    // TODO: Update this to not mutate the manifest from the\n    // build.\n    prerenderManifest.routes[pathname] = {\n      dataRoute: path.posix.join(\n        '/_next/data',\n        `${normalizePagePath(pathname)}.json`\n      ),\n      srcRoute: null, // FIXME: provide actual source route, however, when dynamically appending it doesn't really matter\n      initialRevalidateSeconds: revalidateSeconds,\n    }\n  }\n\n  pathname = normalizePagePath(pathname)\n  cache.set(pathname, {\n    ...data,\n    revalidateAfter: calculateRevalidate(pathname),\n  })\n\n  // TODO: This option needs to cease to exist unless it stops mutating the\n  // `next build` output's manifest.\n  if (sprOptions.flushToDisk) {\n    try {\n      const seedPath = getSeedPath(pathname, 'html')\n      await promises.mkdir(path.dirname(seedPath), { recursive: true })\n      await promises.writeFile(seedPath, data.html, 'utf8')\n      await promises.writeFile(\n        getSeedPath(pathname, 'json'),\n        JSON.stringify(data.pageData),\n        'utf8'\n      )\n    } catch (error) {\n      // failed to flush to disk\n      console.warn('Failed to update prerender files for', pathname, error)\n    }\n  }\n}\n"]}